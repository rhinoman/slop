;; ============================================================
;; SLOP Self-Hosted Parser
;; ============================================================
;;
;; A complete S-expression parser written in SLOP.
;; Demonstrates:
;; - Tagged unions (SExpr variants)
;; - Record types (Token, Lexer state)
;; - String manipulation
;; - Arena allocation
;; - Recursive descent parsing
;;
;; This is the first step toward self-hosting the SLOP compiler.

(module slop-parser
  (export (parse 2) (tokenize 2) (sexpr-print 2))

  (@generation-mode deterministic)

  ;; ============================================================
  ;; AST Types
  ;; ============================================================

  ;; SExpr - the core AST node type
  ;; All SLOP code is represented as S-expressions
  (type SExprKind (enum symbol number string list))

  (type SExpr (record
    (kind SExprKind)
    (sym-val String)       ;; for symbol
    (num-val I64)          ;; for number
    (str-val String)       ;; for string
    (children (Ptr SExprList))))  ;; for list

  ;; Forward declaration - list of SExpr pointers
  (type SExprList (record
    (len I64)
    (cap I64)
    (data (Ptr (Ptr SExpr)))))

  ;; ============================================================
  ;; Token Types
  ;; ============================================================

  (type TokenKind (enum
    tok-lparen    ;; (
    tok-rparen    ;; )
    tok-symbol    ;; identifier or keyword
    tok-number    ;; integer literal
    tok-string    ;; "..."
    tok-quote     ;; '
    tok-eof))     ;; end of input

  (type Token (record
    (kind TokenKind)
    (value String)
    (line I32)
    (col I32)))

  ;; TokenList for storing all tokens
  (type TokenList (record
    (len I64)
    (cap I64)
    (data (Ptr Token))))

  ;; ============================================================
  ;; Lexer State
  ;; ============================================================

  (type Lexer (record
    (source String)
    (pos I64)
    (line I32)
    (col I32)))

  ;; ============================================================
  ;; Character Classification
  ;; ============================================================

  (fn is-whitespace ((c I32))
    (@intent "Check if character is whitespace")
    (@spec ((I32) -> Bool))
    (or (== c 32)    ;; space
        (== c 9)     ;; tab
        (== c 10)    ;; newline
        (== c 13)))  ;; carriage return

  (fn is-digit ((c I32))
    (@intent "Check if character is a digit")
    (@spec ((I32) -> Bool))
    (and (>= c 48) (<= c 57)))  ;; '0'-'9'

  (fn is-alpha ((c I32))
    (@intent "Check if character is alphabetic")
    (@spec ((I32) -> Bool))
    (or (and (>= c 65) (<= c 90))    ;; A-Z
        (and (>= c 97) (<= c 122)))) ;; a-z

  (fn is-symbol-start ((c I32))
    (@intent "Check if character can start a symbol")
    (@spec ((I32) -> Bool))
    (or (is-alpha c)
        (== c 45)    ;; -
        (== c 95)    ;; _
        (== c 64)    ;; @
        (== c 36)    ;; $
        (== c 33)    ;; !
        (== c 63)    ;; ?
        (== c 42)    ;; *
        (== c 43)    ;; +
        (== c 60)    ;; <
        (== c 62)    ;; >
        (== c 61)))  ;; =

  (fn is-symbol-char ((c I32))
    (@intent "Check if character can be part of a symbol")
    (@spec ((I32) -> Bool))
    (or (is-symbol-start c)
        (is-digit c)
        (== c 46)))  ;; .

  ;; ============================================================
  ;; Lexer Functions
  ;; ============================================================

  (fn lexer-new ((source String))
    (@intent "Create a new lexer for the given source")
    (@spec ((String) -> Lexer))
    (record-new Lexer
      (source source)
      (pos 0)
      (line 1)
      (col 1)))

  (fn lexer-peek ((lex (Ptr Lexer)))
    (@intent "Peek at current character without advancing")
    (@spec (((Ptr Lexer)) -> I32))
    (@pre (!= lex nil))
    (if (>= (. lex pos) (string-len (. lex source)))
      0  ;; EOF as null character
      (string-char-at (. lex source) (. lex pos))))

  (fn lexer-advance ((lex (Ptr Lexer)))
    (@intent "Advance lexer by one character")
    (@spec (((Ptr Lexer)) -> I32))
    (@pre (!= lex nil))
    (let ((c (lexer-peek lex)))
      (when (!= c 0)
        (set! lex pos (+ (. lex pos) 1))
        (if (== c 10)
          (do
            (set! lex line (+ (. lex line) 1))
            (set! lex col 1))
          (set! lex col (+ (. lex col) 1))))
      c))

  (fn skip-whitespace-and-comments ((lex (Ptr Lexer)))
    (@intent "Skip whitespace and ; comments")
    (@spec (((Ptr Lexer)) -> Unit))
    (@pre (!= lex nil))
    (while true
      (let ((c (lexer-peek lex)))
        (cond
          ((is-whitespace c)
           (lexer-advance lex))
          ((== c 59)  ;; semicolon - start of comment
           (while (and (!= (lexer-peek lex) 10)
                       (!= (lexer-peek lex) 0))
             (lexer-advance lex)))
          (else
           (return))))))

  (fn read-symbol ((arena Arena) (lex (Ptr Lexer)))
    (@intent "Read a symbol token")
    (@spec ((Arena (Ptr Lexer)) -> String))
    (@pre (!= lex nil))
    (let ((start (. lex pos)))
      (while (is-symbol-char (lexer-peek lex))
        (lexer-advance lex))
      (string-slice (. lex source) start (. lex pos))))

  (fn read-number ((arena Arena) (lex (Ptr Lexer)))
    (@intent "Read a number token")
    (@spec ((Arena (Ptr Lexer)) -> String))
    (@pre (!= lex nil))
    (let ((start (. lex pos)))
      ;; Handle negative sign
      (when (== (lexer-peek lex) 45)
        (lexer-advance lex))
      ;; Read digits
      (while (is-digit (lexer-peek lex))
        (lexer-advance lex))
      (string-slice (. lex source) start (. lex pos))))

  (fn read-string ((arena Arena) (lex (Ptr Lexer)))
    (@intent "Read a string literal (without quotes)")
    (@spec ((Arena (Ptr Lexer)) -> String))
    (@pre (!= lex nil))
    ;; Skip opening quote
    (lexer-advance lex)
    (let ((start (. lex pos)))
      (while (and (!= (lexer-peek lex) 34)  ;; not "
                  (!= (lexer-peek lex) 0))
        ;; Handle escape sequences
        (when (== (lexer-peek lex) 92)  ;; backslash
          (lexer-advance lex))
        (lexer-advance lex))
      (let ((result (string-slice (. lex source) start (. lex pos))))
        ;; Skip closing quote
        (when (== (lexer-peek lex) 34)
          (lexer-advance lex))
        result)))

  (fn next-token ((arena Arena) (lex (Ptr Lexer)))
    (@intent "Get the next token from the lexer")
    (@spec ((Arena (Ptr Lexer)) -> Token))
    (@pre (!= lex nil))

    (skip-whitespace-and-comments lex)

    (let ((line (. lex line))
          (col (. lex col))
          (c (lexer-peek lex)))
      (cond
        ;; EOF
        ((== c 0)
         (record-new Token
           (kind 'tok-eof)
           (value "")
           (line line)
           (col col)))

        ;; Left paren
        ((== c 40)
         (lexer-advance lex)
         (record-new Token
           (kind 'tok-lparen)
           (value "(")
           (line line)
           (col col)))

        ;; Right paren
        ((== c 41)
         (lexer-advance lex)
         (record-new Token
           (kind 'tok-rparen)
           (value ")")
           (line line)
           (col col)))

        ;; Quote
        ((== c 39)
         (lexer-advance lex)
         (record-new Token
           (kind 'tok-quote)
           (value "'")
           (line line)
           (col col)))

        ;; String literal
        ((== c 34)
         (record-new Token
           (kind 'tok-string)
           (value (read-string arena lex))
           (line line)
           (col col)))

        ;; Number (digit or negative sign followed by digit)
        ((or (is-digit c)
             (and (== c 45) (is-digit (string-char-at (. lex source) (+ (. lex pos) 1)))))
         (record-new Token
           (kind 'tok-number)
           (value (read-number arena lex))
           (line line)
           (col col)))

        ;; Symbol
        ((is-symbol-start c)
         (record-new Token
           (kind 'tok-symbol)
           (value (read-symbol arena lex))
           (line line)
           (col col)))

        ;; Unknown character - skip it
        (else
         (lexer-advance lex)
         (next-token arena lex)))))

  ;; ============================================================
  ;; Tokenizer - produces all tokens
  ;; ============================================================

  (fn tokenize ((arena Arena) (source String))
    (@intent "Tokenize SLOP source into a list of tokens")
    (@spec ((Arena String) -> (Ptr TokenList)))
    (@post (!= $result nil))
    (@alloc arena)

    (let ((tokens (arena-alloc arena (sizeof TokenList)))
          (lex-val (lexer-new source))
          (lex (arena-alloc arena (sizeof Lexer))))
      ;; Initialize token list
      (set! tokens len 0)
      (set! tokens cap 64)
      (set! tokens data (arena-alloc arena (* 64 (sizeof Token))))

      ;; Copy lexer to arena
      (set! lex source (. lex-val source))
      (set! lex pos (. lex-val pos))
      (set! lex line (. lex-val line))
      (set! lex col (. lex-val col))

      ;; Tokenize until EOF
      (while true
        (let ((tok (next-token arena lex)))
          ;; Grow array if needed
          (when (>= (. tokens len) (. tokens cap))
            (let ((new-cap (* (. tokens cap) 2))
                  (new-data (arena-alloc arena (* new-cap (sizeof Token)))))
              ;; Copy old data
              (for (i 0 (. tokens len))
                (set! (@ new-data i) (@ (. tokens data) i)))
              (set! tokens data new-data)
              (set! tokens cap new-cap)))

          ;; Store token
          (set! (@ (. tokens data) (. tokens len)) tok)
          (set! tokens len (+ (. tokens len) 1))

          ;; Stop at EOF
          (when (== (. tok kind) 'tok-eof)
            (return tokens))))

      tokens))

  ;; ============================================================
  ;; Parser State
  ;; ============================================================

  (type Parser (record
    (tokens (Ptr TokenList))
    (pos I64)))

  (fn parser-peek ((p (Ptr Parser)))
    (@intent "Peek at current token")
    (@spec (((Ptr Parser)) -> (Ptr Token)))
    (@pre (!= p nil))
    (if (>= (. p pos) (. (. p tokens) len))
      nil
      (addr (@ (. (. p tokens) data) (. p pos)))))

  (fn parser-advance ((p (Ptr Parser)))
    (@intent "Advance parser to next token")
    (@spec (((Ptr Parser)) -> (Ptr Token)))
    (@pre (!= p nil))
    (let ((tok (parser-peek p)))
      (when (!= tok nil)
        (set! p pos (+ (. p pos) 1)))
      tok))

  (fn parser-expect ((p (Ptr Parser)) (kind TokenKind))
    (@intent "Expect a specific token kind")
    (@spec (((Ptr Parser) TokenKind) -> (Ptr Token)))
    (@pre (!= p nil))
    (let ((tok (parser-peek p)))
      (if (and (!= tok nil) (== (. tok kind) kind))
        (parser-advance p)
        nil)))

  ;; ============================================================
  ;; SExpr Constructors
  ;; ============================================================

  (fn sexpr-symbol ((arena Arena) (name String))
    (@intent "Create a symbol SExpr")
    (@spec ((Arena String) -> (Ptr SExpr)))
    (@alloc arena)
    (let ((e (arena-alloc arena (sizeof SExpr))))
      (set! e kind 'symbol)
      (set! e sym-val name)
      e))

  (fn sexpr-number ((arena Arena) (n I64))
    (@intent "Create a number SExpr")
    (@spec ((Arena I64) -> (Ptr SExpr)))
    (@alloc arena)
    (let ((e (arena-alloc arena (sizeof SExpr))))
      (set! e kind 'number)
      (set! e num-val n)
      e))

  (fn sexpr-string ((arena Arena) (s String))
    (@intent "Create a string SExpr")
    (@spec ((Arena String) -> (Ptr SExpr)))
    (@alloc arena)
    (let ((e (arena-alloc arena (sizeof SExpr))))
      (set! e kind 'string)
      (set! e str-val s)
      e))

  (fn sexpr-list ((arena Arena))
    (@intent "Create an empty list SExpr")
    (@spec ((Arena) -> (Ptr SExpr)))
    (@alloc arena)
    (let ((e (arena-alloc arena (sizeof SExpr)))
          (children (arena-alloc arena (sizeof SExprList))))
      (set! children len 0)
      (set! children cap 8)
      (set! children data (arena-alloc arena (* 8 (sizeof (Ptr SExpr)))))
      (set! e kind 'list)
      (set! e children children)
      e))

  (fn sexpr-list-push ((arena Arena) (list (Ptr SExpr)) (item (Ptr SExpr)))
    (@intent "Add an item to a list SExpr")
    (@spec ((Arena (Ptr SExpr) (Ptr SExpr)) -> Unit))
    (@pre (!= list nil))
    (@pre (== (. list kind) 'list))
    (let ((children (. list children)))
      ;; Grow if needed
      (when (>= (. children len) (. children cap))
        (let ((new-cap (* (. children cap) 2))
              (new-data (arena-alloc arena (* new-cap (sizeof (Ptr SExpr))))))
          (for (i 0 (. children len))
            (set! (@ new-data i) (@ (. children data) i)))
          (set! children data new-data)
          (set! children cap new-cap)))
      ;; Add item
      (set! (@ (. children data) (. children len)) item)
      (set! children len (+ (. children len) 1))))

  ;; ============================================================
  ;; Parser Functions
  ;; ============================================================

  (fn parse-expr ((arena Arena) (p (Ptr Parser)))
    (@intent "Parse a single S-expression")
    (@spec ((Arena (Ptr Parser)) -> (Ptr SExpr)))
    (@pre (!= p nil))

    (let ((tok (parser-peek p)))
      (if (== tok nil)
        nil
        (cond
          ;; Quote: 'x -> (quote x)
          ((== (. tok kind) 'tok-quote)
           (parser-advance p)
           (let ((quoted (parse-expr arena p))
                 (result (sexpr-list arena)))
             (sexpr-list-push arena result (sexpr-symbol arena "quote"))
             (when (!= quoted nil)
               (sexpr-list-push arena result quoted))
             result))

          ;; List: (...)
          ((== (. tok kind) 'tok-lparen)
           (parser-advance p)  ;; consume (
           (let ((result (sexpr-list arena)))
             (while true
               (let ((next (parser-peek p)))
                 (cond
                   ((== next nil)
                    (return result))
                   ((== (. next kind) 'tok-rparen)
                    (parser-advance p)  ;; consume )
                    (return result))
                   ((== (. next kind) 'tok-eof)
                    (return result))
                   (else
                    (let ((child (parse-expr arena p)))
                      (when (!= child nil)
                        (sexpr-list-push arena result child)))))))
             result))

          ;; Symbol
          ((== (. tok kind) 'tok-symbol)
           (parser-advance p)
           (sexpr-symbol arena (. tok value)))

          ;; Number
          ((== (. tok kind) 'tok-number)
           (parser-advance p)
           (sexpr-number arena (string-to-int (. tok value))))

          ;; String
          ((== (. tok kind) 'tok-string)
           (parser-advance p)
           (sexpr-string arena (. tok value)))

          ;; Skip unknown
          (else
           (parser-advance p)
           (parse-expr arena p))))))

  ;; ============================================================
  ;; Main Parse Function
  ;; ============================================================

  (fn parse ((arena Arena) (source String))
    (@intent "Parse SLOP source into a list of top-level S-expressions")
    (@spec ((Arena String) -> (Ptr SExprList)))
    (@post (!= $result nil))
    (@alloc arena)

    (let ((tokens (tokenize arena source))
          (p (arena-alloc arena (sizeof Parser)))
          (result (arena-alloc arena (sizeof SExprList))))
      ;; Initialize parser
      (set! p tokens tokens)
      (set! p pos 0)

      ;; Initialize result list
      (set! result len 0)
      (set! result cap 16)
      (set! result data (arena-alloc arena (* 16 (sizeof (Ptr SExpr)))))

      ;; Parse all top-level expressions
      (while true
        (let ((tok (parser-peek p)))
          (when (or (== tok nil)
                    (== (. tok kind) 'tok-eof))
            (return result))

          (let ((expr (parse-expr arena p)))
            (when (!= expr nil)
              ;; Grow if needed
              (when (>= (. result len) (. result cap))
                (let ((new-cap (* (. result cap) 2))
                      (new-data (arena-alloc arena (* new-cap (sizeof (Ptr SExpr))))))
                  (for (i 0 (. result len))
                    (set! (@ new-data i) (@ (. result data) i)))
                  (set! result data new-data)
                  (set! result cap new-cap)))

              (set! (@ (. result data) (. result len)) expr)
              (set! result len (+ (. result len) 1))))))

      result))

  ;; ============================================================
  ;; Pretty Printer
  ;; ============================================================

  (fn sexpr-print ((arena Arena) (expr (Ptr SExpr)))
    (@intent "Pretty-print an S-expression to a string")
    (@spec ((Arena (Ptr SExpr)) -> String))
    (@alloc arena)

    (if (== expr nil)
      "nil"
      (cond
        ((== (. expr kind) 'symbol)
         (. expr sym-val))

        ((== (. expr kind) 'number)
         (int-to-string arena (. expr num-val)))

        ((== (. expr kind) 'string)
         (string-concat arena
           (string-concat arena "\"" (. expr str-val))
           "\""))

        ((== (. expr kind) 'list)
         (let ((result "(")
               (children (. expr children)))
           (for (i 0 (. children len))
             (when (> i 0)
               (set! result (string-concat arena result " ")))
             (set! result (string-concat arena result
                           (sexpr-print arena (@ (. children data) i)))))
           (string-concat arena result ")")))

        (else "?")))))

