/* Generated by SLOP transpiler */
#include "slop_runtime.h"
#include <stdint.h>
#include <stdbool.h>

/* Module: rate-limiter */

typedef struct Limiter Limiter;
typedef struct Status Status;

typedef uint16_t Tokens;

static inline Tokens Tokens_new(int64_t v) {
    SLOP_PRE(v >= 0 && v <= 10000, "Tokens in range 0..10000");
    return (Tokens)v;
}

typedef uint16_t MaxTokens;

static inline MaxTokens MaxTokens_new(int64_t v) {
    SLOP_PRE(v >= 1 && v <= 10000, "MaxTokens in range 1..10000");
    return (MaxTokens)v;
}

typedef uint16_t RefillRate;

static inline RefillRate RefillRate_new(int64_t v) {
    SLOP_PRE(v >= 1 && v <= 1000, "RefillRate in range 1..1000");
    return (RefillRate)v;
}

typedef int64_t Milliseconds;

static inline Milliseconds Milliseconds_new(int64_t v) {
    SLOP_PRE(v >= 0, "Milliseconds >= 0");
    return (Milliseconds)v;
}

struct Limiter {
    MaxTokens max_tokens;
    RefillRate refill_rate;
    Tokens tokens;
    int64_t last_refill;
};
typedef struct Limiter Limiter;

struct Status {
    Tokens available;
    MaxTokens max;
    RefillRate refill_rate;
};
typedef struct Status Status;

typedef enum {
    AcquireResult_acquired,
    AcquireResult_rate_limited
} AcquireResult;

/* Forward declarations */
Limiter* limiter_new(slop_arena* arena, MaxTokens max_tokens, RefillRate refill_rate);
AcquireResult acquire(Limiter* limiter);
AcquireResult try_acquire(Limiter* limiter);
Status* status(slop_arena* arena, Limiter* limiter);
void refill_tokens(Limiter* limiter);

/* Create a new rate limiter with specified capacity and refill rate */
Limiter* limiter_new(slop_arena* arena, MaxTokens max_tokens, RefillRate refill_rate) {
    SLOP_PRE((max_tokens >= 1), "(>= max-tokens 1)");
    SLOP_PRE((refill_rate >= 1), "(>= refill-rate 1)");
    Limiter* _retval;
    __auto_type limiter = (Limiter*)slop_arena_alloc(arena, sizeof(Limiter));
    limiter->max_tokens = max_tokens;
    limiter->refill_rate = refill_rate;
    limiter->tokens = max_tokens;
    limiter->last_refill = slop_now_ms();
    _retval = limiter;
    SLOP_POST((_retval != NULL), "(!= $result nil)");
    return _retval;
}

/* Try to acquire one token, returns result */
AcquireResult acquire(Limiter* limiter) {
    SLOP_PRE((limiter != NULL), "(!= limiter nil)");
    refill_tokens(limiter);
    if ((limiter->tokens > 0)) {
        limiter->tokens = (limiter->tokens - 1);
        return AcquireResult_acquired;
    } else {
        return AcquireResult_rate_limited;
    }
}

/* Non-blocking acquire attempt */
AcquireResult try_acquire(Limiter* limiter) {
    SLOP_PRE((limiter != NULL), "(!= limiter nil)");
    return acquire(limiter);
}

/* Get current rate limiter status */
Status* status(slop_arena* arena, Limiter* limiter) {
    SLOP_PRE((limiter != NULL), "(!= limiter nil)");
    refill_tokens(limiter);
    __auto_type s = (Status*)slop_arena_alloc(arena, sizeof(Status));
    s->available = limiter->tokens;
    s->max = limiter->max_tokens;
    s->refill_rate = limiter->refill_rate;
    return s;
}

/* Add tokens based on elapsed time */
void refill_tokens(Limiter* limiter) {
    SLOP_PRE((limiter != NULL), "(!= limiter nil)");
    __auto_type now = slop_now_ms();
    __auto_type elapsed_ms = (now - limiter->last_refill);
    __auto_type elapsed_sec = (elapsed_ms / 1000);
    __auto_type to_add = (elapsed_sec * limiter->refill_rate);
    __auto_type new_tokens = ((limiter->max_tokens) < ((limiter->tokens + to_add)) ? (limiter->max_tokens) : ((limiter->tokens + to_add)));
    if ((to_add > 0)) {
        limiter->tokens = new_tokens;
        limiter->last_refill = now;
    }
}
