/* Generated by SLOP transpiler */
#include <stdlib.h>
#include <stdio.h>

#include "slop_runtime.h"
#include <stdint.h>
#include <stdbool.h>

/* Module: scoped-ptr */

typedef struct Buffer Buffer;
typedef struct Connection Connection;

struct Buffer {
    uint8_t* data;
    uint64_t size;
};
typedef struct Buffer Buffer;

void Buffer_free(Buffer* ptr) {
    if (!ptr) return;
    if (ptr->data) free(ptr->data);
    free(ptr);
}

struct Connection {
    uint8_t* socket;
    Buffer* read_buf;
    Buffer* write_buf;
};
typedef struct Connection Connection;

void Connection_free(Connection* ptr) {
    if (!ptr) return;
    if (ptr->socket) free(ptr->socket);
    if (ptr->read_buf) Buffer_free(ptr->read_buf);
    if (ptr->write_buf) Buffer_free(ptr->write_buf);
    free(ptr);
}

/* Forward declarations */
Buffer* create_buffer(uint64_t size);
uint8_t process_data(uint64_t len);
uint64_t get_buffer_size(Buffer* buf);
void free_buffer(Buffer* buf);
int main(void);

/* Allocate a buffer of given size */
Buffer* create_buffer(uint64_t size) {
    SLOP_PRE((size > 0), "(> size 0)");
    Buffer* _retval;
    __auto_type buf = ((Buffer*)(malloc(sizeof(Buffer))));
    buf->data = ((uint8_t*)(malloc(size)));
    buf->size = size;
    _retval = buf;
    SLOP_POST(((_retval == NULL) || (_retval != NULL)), "(or (== $result nil) (!= $result nil))");
    return _retval;
}

/* Process data using temporary buffer */
uint8_t process_data(uint64_t len) {
    SLOP_PRE((len > 0), "(> len 0)");
    uint8_t _retval;
    __auto_type temp = ((uint8_t*)(malloc(1024)));
    _retval = (temp != NULL);
    if (temp) free(temp);
    SLOP_POST(((_retval == 1) || (_retval == 0)), "(or (== $result true) (== $result false))");
    return _retval;
}

/* Return the size of a buffer */
uint64_t get_buffer_size(Buffer* buf) {
    SLOP_PRE((buf != NULL), "(!= buf nil)");
    uint64_t _retval;
    _retval = buf->size;
    SLOP_POST((_retval >= 0), "(>= $result 0)");
    return _retval;
}

/* Free a buffer and its data */
void free_buffer(Buffer* buf) {
    SLOP_PRE((buf != NULL), "(!= buf nil)");
    free(((void*)(buf->data)));
    free(((void*)(buf)));
}

/* Demonstrate ScopedPtr automatic cleanup */
int main(void) {
    puts(((uint8_t*)"=== ScopedPtr Demo ==="));
    __auto_type buf = create_buffer(256);
    puts(((uint8_t*)"Created buffer with size:"));
    printf(((uint8_t*)"  %llu bytes\n"), get_buffer_size(buf));
    free_buffer(buf);
    puts(((uint8_t*)"\nTesting process-data with scoped cleanup..."));
    if (process_data(100)) {
        puts(((uint8_t*)"process-data: SUCCESS (temp buffer allocated and auto-freed)"));
    } else {
        puts(((uint8_t*)"process-data: FAILED"));
    }
    puts(((uint8_t*)"\nTesting local scoped pointer..."));
    __auto_type local_buf = ((uint8_t*)(malloc(512)));
    if ((local_buf != NULL)) {
        puts(((uint8_t*)"Local buffer allocated (will be auto-freed at scope end)"));
    } else {
        puts(((uint8_t*)"Local buffer allocation failed"));
    }
    if (local_buf) free(local_buf);
    puts(((uint8_t*)"\nAll scoped pointers cleaned up automatically!"));
    puts(((uint8_t*)"=== Demo Complete ==="));
    return 0;
}
