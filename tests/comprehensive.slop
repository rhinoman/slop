(module comprehensive-test
  (export (main 0))

  (type Score (Int 0 .. 100))

  (type Player (record (name String) (score Score) (active Bool)))

  (type GameState (enum waiting playing paused finished))

  (type Value (union (number Int) (text String) (nothing)))

  (type Scores (Array Int 10))

  (fn bitwise-ops ((a Int) (b Int))
    (@intent "Test bitwise operators")
    (@spec ((Int Int) -> Int))
    (| (& a b) (^ a (<< b 2))))

  (fn sum-array ((scores (Ptr Scores)))
    (@intent "Sum array elements using for loop")
    (@spec (((Ptr Scores)) -> Int))
    (let ((mut total 0))
      (for (i 0 10) (set! total (+ total (@ scores i))))
      total))

  (fn count-down ((mut n Int))
    (@intent "Count iterations using while loop")
    (@spec ((Int) -> Int))
    (let ((mut count 0))
      (while (> n 0)
        (set! count (+ count 1))
        (set! n (- n 1)))
      count))

  (fn state-name ((s GameState))
    (@intent "Map enum to numeric value")
    (@spec ((GameState) -> Int))
    (cond
      ((== s 'waiting) 0)
      ((== s 'playing) 1)
      ((== s 'paused) 2)
      (else 3)))

  (fn extract-value ((v Value))
    (@intent "Extract value from tagged union")
    (@spec ((Value) -> Int))
    (match v
      ((number n) n)
      ((text t) 0)
      ((nothing) -1)))

  (fn divide ((a Int) (b Int))
    (@intent "Safe division returning Result")
    (@spec ((Int Int) -> (Result Int String)))
    (if (== b 0) (error "division by zero") (ok (/ a b))))

  (fn safe-divide-twice ((a Int) (b Int) (c Int))
    (@intent "Chain operations with early return")
    (@spec ((Int Int Int) -> (Result Int String)))
    (let ((first (? (divide a b)))
          (second (? (divide first c))))
      (ok second)))

  (fn classify ((n Int))
    (@intent "Multi-way conditional")
    (@spec ((Int) -> Int))
    (cond
      ((< n 0) -1)
      ((== n 0) 0)
      (else 1)))

  (fn arena-test ()
    (@intent "Test scoped arena allocation")
    (@spec (() -> Int))
    (with-arena 1024
      (let ((p (arena-alloc arena (sizeof Player))))
        (set! p score 42)
        (. p score))))

  (fn sequence-test ((x Int))
    (@intent "Test do sequencing")
    (@spec ((Int) -> Int))
    (do (println "testing") (+ x 1)))

  (fn get-address ((x Int))
    (@intent "Get address of variable")
    (@spec ((Int) -> (Ptr Int)))
    (addr x))

  (fn to-byte ((n Int))
    (@intent "Cast int to byte")
    (@spec ((Int) -> U8))
    (cast U8 n))

  (fn inline-c ()
    (@intent "Test inline C code")
    (@spec (() -> Int))
    (c-inline "42"))

  (fn always-positive ((x Int))
    (@intent "Ensure result is positive")
    (@spec ((Int) -> Int))
    (@post (> $result 0))
    (if (< x 1) 1 x))

  (fn nested-calls ((a Int) (b Int))
    (@intent "Test nested function calls")
    (@spec ((Int Int) -> Int))
    (classify (bitwise-ops a b)))

  (fn option-test ((opt (Option Int)))
    (@intent "Match on Option type")
    (@spec (((Option Int)) -> Int))
    (match opt
      ((some v) v)
      ('none 0)))

  (fn main ()
    (@intent "Entry point")
    (@spec (() -> Int))
    0))
